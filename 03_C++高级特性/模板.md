# 模板

> 本笔记主要针对C++泛型编程（模板）的剖析，开始对C++深层的讨论使用，开始真正的进入到C++。



## 模板

> 模板是一种**泛型编程机制**。允许程序员编写与类型无关的代码。通俗点说，就是写一份代码，可以适用于多种数据类型，大大提高代码复用性。



​	**特点：**

1. 模板只是一个框架，不可以直接使用
2. 模板并不是全都通用
3. C++提供两种模板机制：**函数模板和类模板**





### 函数模板

> 函数模板建立了一个通用函数，函数返回值类型和形参类型**都可以不具体指定**，使用一个虚拟类型来表示。



#### 语法

​	**语法：**

```cpp
template<typename T1 , typename T2 , ....> //可以有多个通用数据类型，本处只研究一种的情况
函数声明或定义
```

> 编译时再根据实参类型推导，生成该类型的函数定义，即实例化过程。



​	**示例：**

```cpp
template<typename T>//T就是自定义的一种通用数据类型
void Swap(T& a, T& b)
{
	T tmp = a;
	a = b;
	b = tmp;
}

int main()
{
	int a = 1, b = 2;
	double c = 1.1, d = 2.2;

	Swap(a, b);
	cout << "a = " << a;
	cout << "b = " << b;

	Swap(c, d);
	cout << "c = " << c;
	cout << "d = " << d;
}
```





#### 注意事项

​	**注意：**

1. **函数模板不能单独使用，必须确定出数据类型 T，两种方式：**
   - 自动类型推导：且必须是一致的数据类型 T
   - 显式指定类型：例如 **`func<int>()`**

​	**示例：**

```cpp
template<class T>
void mySwap(T& a, T& b)
{
	T temp = a;
	a = b;
	b = temp;
}

// 1、自动类型推导，必须推导出一致的数据类型T,才可以使用
void test01()
{
	int a = 10;
	int b = 20;
	char c = 'c';

	mySwap(a, b); // 正确，可以推导出一致的T
	//mySwap(a, c); // 错误，推导不出一致的T类型
}

// 2、显式指定类型
template<class T>
void func()
{
	cout << "func 调用" << endl;
}

void test02()
{
	//func(); //错误，模板不能独立使用，必须确定出T的类型
	func<int>(); //利用显示指定类型的方式，给T一个类型，才可以使用该模板
}

int main() 
{

	test01();
	test02();
	return 0;
}
```





​	**注意：**

2. 普通函数调用时可以发生隐式类型转换

3. 函数模板调用时：

- **自动类型推导：不会发生隐式类型转换**
- 显式类型推导：可以发生隐式类型转换

​	**示例：**

```cpp
//普通函数
int myAdd01(int a, int b)
{
	return a + b;
}

//函数模板
template<class T>
T myAdd02(T a, T b)  
{
	return a + b;
}

//使用函数模板时，如果用自动类型推导，不会发生自动类型转换,即隐式类型转换
void test01()
{
	int a = 10;
	int b = 20;
	char c = 'c';
	
	cout << myAdd01(a, c) << endl; //正确，普通函数，将char类型的'c'隐式转换为int类型  'c' 对应 ASCII码 99

	//myAdd02(a, c); // 报错，模板函数调用，使用自动类型推导时，不会发生隐式类型转换

	myAdd02<int>(a, c); //正确，如果用显示指定类型，可以发生隐式类型转换
}

int main() 
{
	test01();
	return 0;
}
```

> 因此，**建议使用显式指定类型**，可以自己确定要使用的通用类型T





​	**注意：**

4. 函数模板也可以重载

5. 函数模板和普通函数都可以实现，**优先调用普通函数**。（若只声明未实现就会报错）

6. 但是可以通过**空模板参数**来**强制调用函数模板**。函数模板匹配度更高也优先调用函数模板。

​	**示例：**

```cpp
//普通函数与函数模板调用规则
void myPrint(int a, int b)
{
	cout << "调用的普通函数" << endl;
}

template<typename T>
void myPrint(T a, T b) 
{ 
	cout << "调用的模板" << endl;
}

template<typename T>
void myPrint(T a, T b, T c) 
{ 
	cout << "调用重载的模板" << endl; 
}

void test01()
{
    //1、函数模板也可以发生重载
	int c = 30;
	myPrint(a, b, c); //调用重载的函数模板
    
	//2、如果函数模板和普通函数都可以实现，优先调用普通函数
	// 注意 如果告诉编译器  普通函数是有的，但只是声明没有实现，或者不在当前文件内实现，就会报错找不到
	int a = 10;
	int b = 20;
	myPrint(a, b); //调用普通函数

	//3、可以通过空模板参数列表来强制调用函数模板
	myPrint<>(a, b); //调用函数模

	//4、 如果函数模板可以产生更好的匹配,优先调用函数模板
	char c1 = 'a';
	char c2 = 'b';
	myPrint(c1, c2); //调用函数模板，因为使用函数模板可以直接调用，使用普通函数还要进行一次类型转化
}

int main() 
{
	test01();
	return 0;
}
```

> 尽量避免二义性，有了函数模板就不要再声明同名的普通函数。





#### 函数模板具体化

> 由于函数模板有局限性并不能适配所有类型，因此可以单独写一份特殊的模板版本，即具体化。

​	**示例：**

```cpp
template <typename T>
T myMax(T a, T b) 
{
    return (a > b) ? a : b;
}
```

> 例如这个模板就不能处理如结构体等类型的比大小，因此可以具体化比大小，如下：



​	**语法：**

```cpp
template <> 
返回类型 函数名<具体类型>(参数列表) 
{
    // 特殊实现
}
```



​	**示例：**

```cpp
class Person
{
public:
	Person(string name, int age)
	{
		this->m_Name = name;
		this->m_Age = age;
	}
	string m_Name;
	int m_Age;
};

//普通函数模板
template<typename T>
bool myCompare(T& a, T& b)
{
	if (a == b)
	{
		return true;
	}
	else
	{
		return false;
	}
}

//具体化，显示具体化的原型和定意思以template<>开头，并通过名称来指出类型
//具体化优先于常规模板
template<>
bool myCompare(Person &p1, Person &p2)
{
	if (p1.m_Name  == p2.m_Name && p1.m_Age == p2.m_Age)
	{
		return true;
	}
	else
	{
		return false;
	}
}

int main() 
{
	bool ret1 = myCompare(10, 20);
    
    Person p1("Tom", 10);
	Person p2("Tom", 10);
	//自定义数据类型，不会调用普通的函数模板
	//可以创建具体化的Person数据类型的模板，用于特殊处理这个类型
	bool ret2 = myCompare(p1, p2);
}
```

> 编译器调用顺序：普通函数 > 具体化 > 常规模板





#### decltype尾置返回类型

> 尾置返回类型：
>
> ```cpp
> int func(int x,double y);
>     
> 等同于：
> auto func(int x,double y) -> int;
> ```





1. C++ 11，`auto`关键字还不完善 在函数模板里，有些返回值类型依赖参数类型 

​	**示例：**

```cpp
template <typename T1, typename T2>
auto add(T1 a, T2 b) -> decltype(a + b) 
{
    return a + b;
}

int main() 
{
    auto x = add(3, 4);        // int + int → int
    auto y = add(3.5, 2);      // double + int → double
    auto z = add(1L, 2.5f);    // long + float → float

    cout << x << endl;  // 7
    cout << y << endl;  // 5.5
    cout << z << endl;  // 3.5
}

```

> - `auto ... -> decltype(...)` 叫做 **尾置返回类型** ,C++ 11的写法
> - `decltype(a + b)` 表示 “根据表达式 `a + b` 的类型来推导返回值类型”，因此可以保证推导出正确的返回值类型。



2. C++ 14之后，函数的返回值类型就可以直接写 `auto` ,编译器会自行推导。

​	**示例：**

```cpp
template <typename T1, typename T2>
auto add(T1 a, T2 b) 
{
    return a + b;  // 自动根据返回值推导类型
}
```

> 就不用尾置返回类型了，更加简洁。





### 类模板

> 编写**与数据类型无关的类** ，在需要时生成不同类型的类。由于一个类中的数据类型可能存在多种，**因此一个类模板可以有多个 " T "**



#### 语法

​	**语法：**

```cpp
template<class T1 , class T2 , ....>
类
```



​	**示例：**

```cpp
template<class NameType, class AgeType> 
class Person
{
public:
	Person(NameType name, AgeType age)
	{
		this->mName = name;
		this->mAge = age;
	}
	void showPerson()
	{
		cout << "name: " << this->mName << " age: " << this->mAge << endl;
	}
public:
	NameType mName;
	AgeType mAge;
};

void test01()
{
	// 指定NameType 为string类型，AgeType 为 int类型
	Person<string, int>P1("孙悟空", 999);
	P1.showPerson();
}

int main() 
{
	test01();
	return 0;
}
```





#### 注意事项

​	**注意：**

1. **类模板没有自动类型推导**，创建对象时**必须指明**具体的数据类型
2. 类模板的**模板参数列表里面可以有默认参数类型** （C++ 11之后函数模板也支持）



​	**示例：**

```cpp
template<class NameType, class AgeType = int> //默认参数指定为整形
class Person
{
public:
	Person(NameType name, AgeType age)
	{
		this->mName = name;
		this->mAge = age;
	}
	void showPerson()
	{
		cout << "name: " << this->mName << " age: " << this->mAge << endl;
	}
public:
	NameType mName;
	AgeType mAge;
};

//1、类模板没有自动类型推导的使用方式
void test01()
{
	// Person p("孙悟空", 1000); // 错误 类模板使用时候，不可以用自动类型推导
	Person <string ,int>p("孙悟空", 1000); //必须使用显示指定类型的方式，使用类模板
	p.showPerson();
}

//2、类模板在模板参数列表中可以有默认参数
void test02()
{
	Person <string> p("猪八戒", 999); //类模板中的模板参数列表 可以指定默认参数
	p.showPerson();
}
```





​	**注意：**

3. 普通类中的成员函数一开始就可以创建,**而类模板中的成员函数在调用时才创建。**



​	**示例：**

```cpp
class Person1
{
public:
	void showPerson1()
	{
		cout << "Person1 show" << endl;
	}
};

class Person2
{
public:
	void showPerson2()
	{
		cout << "Person2 show" << endl;
	}
};

template<class T>
class MyClass
{
public:
	T obj;

	//类模板中的成员函数，并不是一开始就创建的，而是在模板调用时再生成
	void fun1() { obj.showPerson1(); }
	void fun2() { obj.showPerson2(); }
};

void test01()
{
	MyClass<Person1> m;
	m.fun1();
	//m.fun2();//编译会出错，说明函数调用才会去创建成员函数
}

int main() 
{
	test01();
	return 0;
}
```





#### 类模板分文件编写

> 由上文注意事项3：类模板中成员函数的创建时期是在调用阶段，因此会导致分文件编写时会连接不到



​	**解决方案：**

1. 直接包含 `.cpp` 源文件
2. 将声明和实现写到同一个文件中，并改后缀名为 `.hpp` , 约定俗成并不强制为 `.hpp` 

> 主流方法为 `.hpp` 



​	**示例：**

```cpp
person.hpp
```

```cpp
#pragma once //防止覆盖
#include <iostream>
using namespace std;
#include <string>

template<class T1, class T2>
class Person {
public:
	Person(T1 name, T2 age);
	void showPerson();
public:
	T1 m_Name;
	T2 m_Age;
};

//构造函数 类外实现
template<class T1, class T2>
Person<T1, T2>::Person(T1 name, T2 age) {
	this->m_Name = name;
	this->m_Age = age;
}

//成员函数 类外实现
template<class T1, class T2>
void Person<T1, T2>::showPerson() {
	cout << "姓名: " << this->m_Name << " 年龄:" << this->m_Age << endl;
}
```



​	**示例：**

```cpp
.cpp
```

```cpp
#include<iostream>
using namespace std;

//#include "person.h"
#include "person.cpp" //解决方式1，改包含.h为 包含.cpp源文件 实践中少用

//解决方式2，将声明和实现写到一起，文件后缀名改为.hpp
#include "person.hpp"
void test01()
{
	Person<string, int> p("Tom", 10);
	p.showPerson();
}

int main() {

	test01();

	system("pause");

	return 0;
}
```





#### 类模板对象做函数参数

> 类模板实例化的对象也可以作为函数的参数



​	**三种方式：**

| 方式                                            | 示例                                                         |
| ----------------------------------------------- | ------------------------------------------------------------ |
| **普通函数：** 参数和返回值是类模板的实例化版本 | **`Person<string,int> func(Person<string,int>& p)`**         |
| **函数模板：** 参数和返回值是类模板             | **`template<class T1,class T2>   Person<T1,T2> func(Person<T1,T2>& p)`** |
| **函数模板：** 参数和返回值可以是任意类型       | **`template<class T>   T func(T& p)`**                       |

> 返回值的类型可以是其他类型如 `void` ,但是参数类型一定是如上要求。



​	**示例：**

```cpp
//类模板对象做函数参数
template<class T1,class T2>
class Person
{
public:
	Person(T1 name, T2 age):m_name(name),m_age(age){}

	void ShowPerson()
	{
		cout << "姓名：" << m_name << "年龄：" << m_age;
	}

	T1 m_name;
	T2 m_age;
};

// 1.传入指定的类型的对象
void PrintPerson01(Person<string, int>&p)
{
	p.ShowPerson();
}

void Test01()
{
	Person<string, int>p("孙悟空", 100);
	PrintPerson01(p);
}


// 2.传入参数模板化的对象
template<class T1,class T2>
void PrintPerson02(Person<T1, T2>& p)
{
	p.ShowPerson();
}

void Test02()
{
	Person<string, int>p("猪八戒", 90);
	PrintPerson02(p);
}


// 3.传入整个类都模板化的对象
template<class T>
void PrintfPerson03(T &p)
{
	p.ShowPerson();
}

void Test03()
{
	Person<string, int>p("沙和尚", 80);
	PrintfPerson03(p);
}


int main()
{
	Test01();
	Test02();
	Test03();
	return 0;
}
```

> 比较常用的是传入指定类型的用法





#### 类模板与继承



​	**注意：**

1. **当父类是一个类模板时，普通子类在继承声明时，必须指定出父类中 T 的具体类型**
2. 若子类也为模板类，就可以直接写为通用数据类型 T 。



```cpp
template<class T>
class Base
{
	T m;
};

//class Son:public Base  //错误，c++编译需要给子类分配内存，必须知道父类中T的类型才可以向下继承
class Son :public Base<int> //必须指定一个类型
{
};
void test01()
{
	Son c;
}

//类模板继承类模板 ,可以用T2指定父类中的T类型
template<class T1, class T2>
class Son2 :public Base<T2>
{
public:
	Son2()
	{
		cout << typeid(T1).name() << endl;
		cout << typeid(T2).name() << endl;
	}
};

void test02()
{
	Son2<int, char> child1;
}

int main()
{
	test01();
	test02();
	return 0;
}
```





#### 类模板中成员函数的类外实现



​	**注意：**

1. 与普通类的成员函数的类外声明相比较：
   - 不仅仅只需要加上 **`类名::`** ，需要额外加上 **`类名<声明用到的通用数据类型 T>::`** 的尖括号部分。
2. 构造函数不需要返回值，其他成员函数在最前面加上返回值类型，与普通类规则相同。



​	**示例：**

```cpp
template<class T1,class T2>
class Person
{
public:
	Person(T1 name, T2 age);

	void ShowPerson();

	T1 m_name;
	T2 m_age;
};

//构造函数类外实现
template<class T1,class T2>
Person<T1,T2>::Person(T1 name,T2 age):m_name(name),m_age(age){}

//普通成员函数类外实现
template<class T1,class T2>
void Person<T1, T2>::ShowPerson()
{
	//...;
}
```





#### 类模板的友元

| 方式              | 注意                                                    |
| ----------------- | ------------------------------------------------------- |
| 普通函数/类做友元 | 只是与模板类绑定的普通函数/类，可以访问模板类的私有成员 |
| 模板函数做友元    | 注意类外实现的写法，**需要加一个参数列表**              |
| 模板类做友元      | 模板类之间共享私有成员                                  |



​	**示例：**

```cpp
// 1.普通函数/类做模板类的友元
template<class T>
class A
{
private:
	T data;
public:
	A(T d):data(d){}

	friend void PrintA(const A& a)
	{
		cout << a.data;
	}
};


// 2.函数模板做类模板的友元
template<class T>
class A;

template<class T>
void PrintA(const A<T>& a);

template<class T>
class A
{
private:
	T data;
public:
	A(T d):data(d){}

	friend void PrintA<>(const A<T>& a);//类内声明，类外实现时需要加一个参数列表<>,可以空、T、int...
};

template<class T>
void PrintA(const A<T>& a)
{
	cout << a.data;
}


// 3.类模板做类模板友元
template <typename T> class B; // 提前声明

template <typename T>
class A {
private:
	T data;
public:
	A(T d) : data(d) {}
	// 让 B<T> 成为 A<T> 的朋友
	friend class B<T>;
};

template <typename T>
class B 
{
public:
	void show(const A<T>& a) 
	{
		cout << a.data << endl; // 可以访问 A<T> 的私有成员
	}
};
```





#### 类模板具体化

1. **完全具体化** 

​	**示例：**

```cpp
// 通用模板
template <typename T>
class Box 
{
public:
    void show()
    {
        cout << "通用模板" << endl;
    }
};

// 完全特化：针对 int
template <>
class Box<int> 
{
public:
    void show() 
    {
        cout << "int 特化版本" << endl;
    }
};

int main() 
{
    Box<double> b1;
    b1.show();  // 输出: 通用模板

    Box<int> b2;
    b2.show();  // 输出: int 特化版本
}
```

> 完全具体化之后就不是模板，而是一个普通类了



2. **部分具体化**：对某一类类型进行具体化处理

​	**示例：**

```cpp
// 通用模板
template <typename T1, typename T2>
class Pair
{
public:
    void show() 
    {
        cout << "通用模板" << endl;
    }
};

// 部分特化：当两个类型相同时
template <typename T>
class Pair<T, T> 
{
public:
    void show() 
    {
        cout << "部分特化：两个类型相同" << endl;
    }
};

// 部分特化：第二个类型固定为 int
template <typename T>
class Pair<T, int> 
{
public:
    void show() 
    {
        cout << "部分特化：第二个是 int" << endl;
    }
};

int main() 
{
    Pair<double, char> p1;
    p1.show();  // 通用模板

    Pair<int, int> p2;
    p2.show();  // 部分特化：两个类型相同

    Pair<double, int> p3;
    p3.show();  // 部分特化：第二个是 int
}
```



3. **成员函数具体化**：将类模板的成员函数进行具体化

​	**示例：**

```cpp
template <typename T>
class Box 
{
public:
    void show() 
    {
        cout << "通用 show" << endl;
    }
    void print();
};

// 成员函数特化
template <>
void Box<int>::print()
{
    cout << "print 的 int 特化" << endl;
}

template <typename T>
void Box<T>::print() 
{
    cout << "通用 print" << endl;
}
```





#### 案例：实现一个通用的数组类

​	**实现：**

- 可以对内置数据类型以及**自定义数据类型**的数据进行存储
- 将数组中的数据存储到堆区
- 构造函数中可以传入数组的容量
- 提供对应的拷贝构造函数以及operator=防止浅拷贝问题
- 提供尾插法和尾删法对数组中的数据进行增加和删除
- 可以通过下标的方式访问数组中的元素
- 可以获取数组中当前元素个数和数组的容量



1. myArray.hpp

```cpp
#pragma once
#include <iostream>
using namespace std;

template<class T>
class MyArray
{
public:
    
	//构造函数
	MyArray(int capacity)
	{
		this->m_Capacity = capacity;
		this->m_Size = 0;
		pAddress = new T[this->m_Capacity];
	}

	//拷贝构造
	MyArray(const MyArray & arr)
	{
		this->m_Capacity = arr.m_Capacity;
		this->m_Size = arr.m_Size;
		this->pAddress = new T[this->m_Capacity];
		for (int i = 0; i < this->m_Size; i++)
		{
			//如果T为对象，而且还包含指针，必须需要重载 = 操作符，因为这个等号不是 构造 而是赋值，
			// 普通类型可以直接= 但是指针类型需要深拷贝
			this->pAddress[i] = arr.pAddress[i];
		}
	}

	//重载= 操作符  防止浅拷贝问题
	MyArray& operator=(const MyArray& myarray) {

		if (this->pAddress != NULL) {
			delete[] this->pAddress;
			this->m_Capacity = 0;
			this->m_Size = 0;
		}

		this->m_Capacity = myarray.m_Capacity;
		this->m_Size = myarray.m_Size;
		this->pAddress = new T[this->m_Capacity];
		for (int i = 0; i < this->m_Size; i++) {
			this->pAddress[i] = myarray[i];
		}
		return *this;
	}

	//重载[] 操作符  arr[0]
	T& operator [](int index)
	{
		return this->pAddress[index]; //不考虑越界，用户自己去处理
	}

	//尾插法
	void Push_back(const T & val)
	{
		if (this->m_Capacity == this->m_Size)
		{
			return;
		}
		this->pAddress[this->m_Size] = val;
		this->m_Size++;
	}

	//尾删法
	void Pop_back()
	{
		if (this->m_Size == 0)
		{
			return;
		}
		this->m_Size--;
	}

	//获取数组容量
	int getCapacity()
	{
		return this->m_Capacity;
	}

	//获取数组大小
	int	getSize()
	{
		return this->m_Size;
	}


	//析构
	~MyArray()
	{
		if (this->pAddress != NULL)
		{
			delete[] this->pAddress;
			this->pAddress = NULL;
			this->m_Capacity = 0;
			this->m_Size = 0;
		}
	}

private:
	T * pAddress;  //指向一个堆空间，这个空间存储真正的数据
	int m_Capacity; //容量
	int m_Size;   // 大小
};
```



2.  .cpp

```cpp
#include "myArray.hpp"
#include <string>

void printIntArray(MyArray<int>& arr) {
	for (int i = 0; i < arr.getSize(); i++) {
		cout << arr[i] << " ";
	}
	cout << endl;
}

//测试内置数据类型
void test01()
{
	MyArray<int> array1(10);
	for (int i = 0; i < 10; i++)
	{
		array1.Push_back(i);
	}
	cout << "array1打印输出：" << endl;
	printIntArray(array1);
	cout << "array1的大小：" << array1.getSize() << endl;
	cout << "array1的容量：" << array1.getCapacity() << endl;

	cout << "--------------------------" << endl;

	MyArray<int> array2(array1);
	array2.Pop_back();
	cout << "array2打印输出：" << endl;
	printIntArray(array2);
	cout << "array2的大小：" << array2.getSize() << endl;
	cout << "array2的容量：" << array2.getCapacity() << endl;
}

//测试自定义数据类型
class Person {
public:
	Person() {} 
		Person(string name, int age) {
		this->m_Name = name;
		this->m_Age = age;
	}
public:
	string m_Name;
	int m_Age;
};

void printPersonArray(MyArray<Person>& personArr)
{
	for (int i = 0; i < personArr.getSize(); i++) {
		cout << "姓名：" << personArr[i].m_Name << " 年龄： " << personArr[i].m_Age << endl;
	}

}

void test02()
{
	//创建数组
	MyArray<Person> pArray(10);
	Person p1("孙悟空", 30);
	Person p2("韩信", 20);
	Person p3("妲己", 18);
	Person p4("王昭君", 15);
	Person p5("赵云", 24);

	//插入数据
	pArray.Push_back(p1);
	pArray.Push_back(p2);
	pArray.Push_back(p3);
	pArray.Push_back(p4);
	pArray.Push_back(p5);

	printPersonArray(pArray);

	cout << "pArray的大小：" << pArray.getSize() << endl;
	cout << "pArray的容量：" << pArray.getCapacity() << endl;

}

int main() {

	//test01();

	test02();

	system("pause");

	return 0;
}
```

