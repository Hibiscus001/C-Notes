# 可调用对象

> C++ 提供了多种方式来表示和操作可调用对象，包括**全局函数**、**函数指针**、**仿函数（Functors）**、**Lambda表达式**、**`std::function`** 和 **`std::bind`** 等。
>
> 这些工具极大地增强了C++的灵活性和表达能力，尤其在**处理回调、事件驱动编程、泛型算法、并发编程等**表现尤为出色。



👉 **可以理解为：**

- **函数指针**：传统手段
- **仿函数 & Lambda**：现代可调用对象
- **`std::function`**：统一接口，装下所有可调用对象
- **`std::bind`**：参数绑定/成员函数适配



## 函数指针

> C++最基本的可调用对象。**指向函数的指针变量**，保留了某个函数的**入口地址**。



### 基本语法

```cpp
#include <iostream>

// 定义函数指针类型的变量
int (*funcPtr)(int, int);
// using funcPtr = int(*) (int, int); //一样的意思

// 定义一个普通函数
int add(int a, int b)
{
  return a + b;
}

int main()
{
  // 使函数指针指向函数
  // funcPtr = add;  //两种写法都可以，函数名会自动转换成函数指针，类比于数组名即数组首地址
  funcPtr = &add;

  // (*funcPtr)(2, 3) //可以不解引用，编译器会自行调用函数
  std::cout << funcPtr(1, 2); 
  return 0;
}
```

> `funcPtr` 即函数指针。



### 常用处

#### 回调机制

```cpp
#include <iostream>

// 定义函数指针类型
using FuncPtr = int(*)(int, int);

void compute(int a, int b, FuncPtr f) 
{
    std::cout << "Result: " << f(a, b) << std::endl;
}

int add(int a, int b) { return a + b; }
int sub(int a, int b) { return a - b; }

int main()
{
    compute(5, 3, add); // 传入不同的函数
    compute(5, 3, sub);
}
```



#### 函数指针数组

> 可以保存多个函数指针，用来实现 **“函数表”**：

```cpp
int add(int a, int b) { return a + b; }
int sub(int a, int b) { return a - b; }

int (*ops[2])(int, int) = { add, sub };

int main() 
{
    std::cout << ops[0](3, 2) << std::endl; // add
    std::cout << ops[1](3, 2) << std::endl; // sub
}
```



#### 成员函数指针

> 普通函数指针只能指向**全局函数**或**静态成员函数**；
> 若要指向类的非静态成员函数，需要 **成员函数指针**：

```cpp
class Foo 
{
    int bar(int x) { return x + 1; }
};

int main() 
{
    Foo foo;
    int (Foo::*mp)(int) = &Foo::bar; // 成员函数指针
    std::cout << (foo.*mp)(10) << std::endl; // 调用
}
```

> 加作用域即可。



### 总结

​	**优点：**

1. 简单直观，适用于简单的回调函数

​	**缺点：**

2. **不能捕获上下文**，与 `lambda` 表达式本质的区别。
3. 语法相对难写难看





## 仿函数(Functors)

> **仿函数（Functors）**，又称**函数对象（Function Objects）**，是在C++中重载了 `operator()` 的类或结构体实例。
>
> 仿函数不仅可以像普通函数一样被调用，**还能携带状态**，提供更大的灵活性和功能性。

| 特性     | 普通函数           | 函数对象                             |
| -------- | ------------------ | ------------------------------------ |
| 本质     | 一段可执行代码     | 类的实例（对象）                     |
| 定义     | 只能在定义时实例化 | 类中**重载 `operator()` 运算符**实现 |
| 调用方式 | `f(x)`             | `obj(x)`                             |
| 状态     | 无法保存           | **可保存成员变量的状态**             |
| 应用场景 | 单次功能调用       | STL 算法、自定义行为、可携带数据     |



### 基本语法

```cpp
#include <iostream>
struct Adder
{
  int to_add;
  Adder(int value) : to_add(value) {}

  int operator()(int x)
  {
    return x + to_add;
  }
};

int main()
{
  Adder add(5);	//先调用构造函数，携带状态
  std::cout << add(10) << std::endl;	//保存状态，运行10+5
}
```



​	**示例：**

```cpp
//1、函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值
class MyAdd
{
public :
	int operator()(int v1,int v2)
	{
		return v1 + v2;
	}
};

void test01()
{
	MyAdd myAdd;
	cout << myAdd(10, 10) << endl;
}

//2、函数对象可以有自己的状态
class MyPrint
{
public:
	MyPrint()
	{
		count = 0;
	}
	void operator()(string test)
	{
		cout << test << endl;
		count++; //统计使用次数
	}

	int count; //内部自己的状态
};
void test02()
{
	MyPrint myPrint;
	myPrint("hello world");
	myPrint("hello world");
	myPrint("hello world");
	cout << "myPrint调用次数为： " << myPrint.count << endl;
}

//3、函数对象可以作为参数传递
void doPrint(MyPrint &mp , string test)
{
	mp(test);
}

void test03()
{
	MyPrint myPrint;
	doPrint(myPrint, "Hello C++");
}

int main()
{
	//test01();
	//test02();
	test03();
	return 0;
}
```



### 常用处

#### 仿函数与STL通用算法

> 仿函数常用于 [STL通用算法函数](./STL基础语法#STL通用算法) 的可扩展接口处。

​	**示例：**

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

// 仿函数：判断一个数是否大于某个阈值
struct IsGreaterThan 
{
    int threshold;
    IsGreaterThan(int t) : threshold(t) {}
    bool operator()(int x) const 
    {
        return x > threshold;
    }
};

int main() 
{
    std::vector<int> numbers = {1, 5, 10, 15, 20};

    // 使用仿函数进行筛选
    IsGreaterThan greaterThan10(10);
    auto it = std::find_if(numbers.begin(), numbers.end(), greaterThan10);

    if(it != numbers.end()) 
    {
        std::cout << "第一个大于10的数是: " << *it << std::endl; // 输出: 第一个大于10的数是: 15
    } 
    else 
    {
        std::cout << "没有找到大于10的数。" << std::endl;
    }
    return 0;
}
```



#### 仿函数与模板

> 仿函数与模板相结合，可以实现高度通用和可复用的代码。例如，编写一个通用的比较仿函数。

​	**示例：**

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

// 通用比较仿函数
template <typename T>
struct Compare
{
    bool operator()(const T& a, const T& b) const 
    {
        return a < b;
    }
};

int main() 
{
    std::vector<int> numbers = {5, 2, 8, 1, 9};

    // 使用仿函数进行排序
    std::sort(numbers.begin(), numbers.end(), Compare<int>());

    std::cout << "排序后的数字: ";
    for(auto num : numbers)
    {
        std::cout << num << " "; // 输出: 1 2 5 8 9
    }
    std::cout << std::endl;

    return 0;
}
```



### 总结

| **优势**               | **描述**                                                     |
| ---------------------- | ------------------------------------------------------------ |
| **可扩展性**           | 可以根据需求灵活地添加更多功能和状态，适应复杂的应用场景。   |
| **与 Lambda 的互补性** | 当需要携带复杂状态或多次调用时，仿函数比 Lambda 更加合适，具有更强的灵活性。 |
| **类型安全**           | 仿函数是具体的类型，编译器可以进行类型检查，确保类型安全。   |



| **使用场景**       | **描述**                                                     |
| ------------------ | ------------------------------------------------------------ |
| **需要携带状态时** | 当回调函数需要维护内部状态时，仿函数非常适用，能够持久化状态信息。 |
| **复杂操作**       | 在简单的函数指针或 Lambda 无法表达复杂逻辑时，仿函数提供更高的表达能力。 |
| **性能关键场景**   | 仿函数能被编译器优化，适用于需要高性能的代码，特别是在大量调用时。 |





## lambda表达式

> C++11 。`lambda` 表达式**本质上**是一个**匿名类的对象 (仿函数)**。



### 基本语法

```cpp
[capture](parameter_list) -> return_type 
{
    function_body;
};
```

- **`[capture]` 捕获列表**：指定如何捕获使用外部作用域的变量。

- **`parameter_list` 参数列表**：和普通函数一样。

- **`return_type` 返回类型**：可以省略（C++14+ 编译器能自动推导）。

- **`function_body` 函数体**：实际执行的逻辑。



​	**捕获列表（重点）：**

| 捕获方式    | 示例                              | 含义                                                         |
| ----------- | --------------------------------- | ------------------------------------------------------------ |
| `[ ]`       | `[ ](){ }`                        | 不捕获任何外部变量                                           |
| `[=]`       | `[=](){ return a + b; }`          | 按值捕获（拷贝外部变量）<br />加 `mutable` 关键字可以修改拷贝副本 |
| `[&]`       | `[&](){ b += 1; }`                | 按引用捕获（允许修改外部变量）                               |
| `[a]`       | `[a](){ return a*2; }`            | 只捕获变量 `a`（按值）                                       |
| `[&a]`      | `[&a](){ a++; }`                  | 只捕获变量 `a`（按引用）                                     |
| `[=,&b]`    | `[=,&b](){ b++; return a+b; }`    | `a` 按值，`b` 按引用                                         |
| `[this]`    | `[this]{ return this->member; }`  | 捕获当前对象（在类里常用）                                   |
| `[=, this]` | `[=]{ return this->member + a; }` | 捕获所有外部变量按值 + 当前对象                              |

 

​	**示例：**

```cpp
#include <iostream>
int main()
{
  int x = 10, y = 20;

  auto f1 = [=]() { return x + y; };	//返回30，此处是按值捕获，即拷贝一份，默认是只读const，不能修改，因此不能++x

  auto f2 = [&]() { return ++x + ++y; };	//返回32，此处是引用捕获，访问的是真实的x和y
     
  cout << f1() << endl; // 30
  cout << f2() << endl; // 32 （修改了 x,y）
}
```

> 因为 `lambda` 本质是匿名类对象，所以调用的时候也是以 `f()` 这种加括号的形式。



### 常用处

#### 修改拷贝捕获修改权限

> `lambda` 表达式**拷贝按值捕获默认是 `const` 只读**，**不可修改**。但是可以加上 **`mutable` 关键字**允许修改捕获的变量副本**(仅副本)**。

​	

​	**上述例子修改：**

```cpp
#include <iostream>
using namespace std;

int main()
{
  int x = 10, y = 20;

  auto f1 = [=]() mutable
  { return ++x + ++y; }; // 此处可以修改x和y的副本

  cout << f1() << endl; // 32

  cout << x << y;	// 还是10和20
}
```

> 使用 **`mutable` 关键字**可以修改按值捕获的拷贝变量，但是**只修改了副本**，不影响外部 `x` 和 `y` 的值。



#### 捕获this

> Lambda表达式可以捕获类的成员变量和成员函数，使其在类的上下文中更加灵活。**即捕获 `this`。**

​	**示例：**

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

// 处理器类
class Processor
{
public:
  Processor(int threshold) : _threshold(threshold) {}

  // 处理数据的函数
  void process(std::vector<int> &data)
  {
    std::cout << "before process data: ";
    for (auto num : data)
    {
      std::cout << num << " ";
    }
    std::cout << std::endl;

    // 循环将满足小于 _threshold 的值移动到数组末尾，会返回指向新逻辑结尾的迭代器
    auto new_end = std::remove_if(data.begin(), data.end(), [this](int n)	//捕获当前对象，即可访问私有成员
                                  { return n < _threshold; });

    // 删除逻辑结尾到真实结尾的数据即删除所有满足条件的数据
    data.erase(new_end, data.end());

    // 打印处理后的数据
    std::cout << "have processed data: ";
    for (auto num : data)
    {
      std::cout << num << " ";
    }
    std::cout << std::endl;
  }

private:
  int _threshold;
};

int main()
{
  // 设置阈值为5
  Processor processor(5);

  std::vector<int> vec{0, 2, 4, 6, 8, 10};
  processor.process(vec);
  return 0;
}
```



#### lambda与STL通用算法

> 和仿函数一样常用于 [STL通用算法函数](./STL基础语法#STL通用算法) 的可扩展接口处。

​	**示例：**

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> numbers = {4, 2, 5, 1, 3};

    // 使用Lambda表达式进行排序
    std::sort(numbers.begin(), numbers.end(),
        [](int a, int b) -> bool {
            return a < b;
        });

    std::cout << "排序后的数字: ";
    for(auto num : numbers) {
        std::cout << num << " "; // 输出: 1 2 3 4 5
    }
    std::cout << std::endl;

    return 0;
}
```



### 总结

| **优势**              | **描述**                                                     |
| --------------------- | ------------------------------------------------------------ |
| **简洁**              | 匿名类对象，相比于仿函数，不需要外部定义，代码更紧凑，易于理解。 |
| **灵活**              | 支持按需捕获外部对象，能够实现类似闭包的功能，使得代码更加灵活。 |
| **性能优化**          | 编译器会对 lambda 表达式进行优化，类似内联展开，减少不必要的函数调用。 |
| **结合 STL 通用算法** | 能够与 STL 通用算法（如 `std::sort`）无缝结合，提高代码逻辑的简洁性与效率。 |

| 缺点     | 描述                                                         |
| -------- | ------------------------------------------------------------ |
| 逻辑难懂 | 因为是匿名类对象，相当于声明和实现写在一起了，没有独立的函数体，特别是在函数回调使用时有点难看懂。 |



## std::function

> `std::function` 是**C++11**提供的一个**模板类**，能够**封装任何可调用对象**。头文件 `<functional>`
>
> 它实现了**类型擦除**，使得不同类型的可调用对象**可以通过统一的接口进行操作**。



### 基本语法

> 由于`std::function` 是一个模板类，因此其模板参数指定了函数的签名：
>
> 例如 **`function<int (int ,int)>`** 第一个int是返回类型，后两个int是参数类型。一起指定了实例化对象的数据类型。



​	**示例：**

```cpp
#include <iostream>
#include <functional>

// 普通函数
int add(int a, int b)
{
  return a + b;
}

// 函数对象,乘法类
struct Multiply
{
  int operator()(int a, int b) const
  {
    return a * b;
  }
};

int main()
{
  // 封装普通函数 std::function是模板类，<>内数据类型表示了其实例化对象的数据类型，第一个int是返回类型，后两个int是参数类型
  std::function<int(int, int)> func1 = add; // 拷贝构造
  std::cout << "+ :" << func1(3, 4) << std::endl;

  //封装仿函数
  Multiply multiply;
  std::function<int(int, int)> func2 = multiply;
  std::cout << "* :" << func2(3, 4) << std::endl;

  // lambda表达式
  std::function<int(int, int)> func3 = [](int a, int b)
  { return a - b; };
  std::cout << "- :" << func3(3, 4) << std::endl;
}
```



### 常用处

#### 回调机制

```cpp
#include <iostream>
#include <functional>

// 定义回调类型
using Callback = std::function<void(int)>; // 此时Callback=function类

// 触发事件的函数
void triggerEvent(Callback cb, int value) // 回调对象和其值
{
  // 事件发生就调用回调函数
  value *= 2;
  cb(value);
}

int main()
{
  // 定义回调函数,使用lambda表达式
  triggerEvent([](int x)
               { std::cout << "事件触发，值为:" << x << std::endl; }, 42);

  // 定义回调函数,使用仿函数
  struct Printer
  {
    void operator()(int x) const
    {
      std::cout << "Printer打印值:" << x << std::endl;
    }
  } printer;

  triggerEvent(printer, 100);

  return 0;
}
```



#### 集体存储与调用

```cpp
#include <iostream>
#include <functional>
#include <vector>

int add(int a, int b)
{
  return a + b;
}

struct Multiply
{
  int operator()(int a, int b) const
  {
    return a * b;
  }
};

int main()
{
  std::vector<std::function<int(int, int)>> vec_func; // 创建了元素类型为function的数组

  vec_func.emplace_back(add);
  vec_func.emplace_back(Multiply()); // 创建了一个类的临时对象，就不用再实例化再拷贝一份增加开销
  vec_func.emplace_back([](int a, int b)
                        { return a - b; });

  for (auto &tmp : vec_func)	//引用减少开销
  {
    std::cout << tmp(10, 5) << std::endl;
  }

  return 0;
}
```



### 总结

| **优势**     | **描述**                                                     |
| ------------ | ------------------------------------------------------------ |
| **类型擦除** | 可以**存储任何符合签名的可调用对象**，支持不同类型的函数、Lambda 和仿函数等。 |
| **灵活**     | 支持动态改变存储的可调用对象，使得代码更具灵活性和可扩展性。 |

| **缺点** | **描述**                                                     |
| -------- | ------------------------------------------------------------ |
| **开销** | 相比于直接使用函数指针或 Lambda，其开销略高，因为 `std::function` 需要进行类型擦除和动态内存分配。 |



## std::bind

> `std::bind` 是**C++11**提供的一个**函数模板。** 将可调用对象与其**部分参数**绑定，生成新的可调用对象。头文件 `<functional>`

> 其主要用途是**根据需要只绑定部分参数** ，**延迟执行**。常用于回调和异步中。



### 基本语法

```cpp
std::bind(Callable&& f, Arg1&& arg1, Arg2&& arg2, ..., ArgN&& argN)
```

- **`Callable`**：**要绑定的可调用对象**（可以是函数、Lambda、仿函数等）。
- **`Arg1, Arg2, ..., ArgN`**：要绑定的参数。绑定的参数可以是函数的某些固定参数，或者使用**占位符** `_1`, `_2` 等表示的未来参数。

> `std::bind` 会返回一个新的可调用对象，可以传入剩余的未绑定参数。



​	**示例：**

```cpp
#include <iostream>
#include <functional>   // std::bind, std::function, std::placeholders

// 仿函数类（函数对象）
struct Operation 
{
    int operator()(int a, int b, int c) const 
    {
        std::cout << "Operation called: ";
        std::cout << a << " + " << b << " + " << c << " = ";
        return a + b + c;
    }
};

int main() 
{
    Operation op;  // 创建仿函数对象

    // 绑定仿函数的三个参数中的一部分
    // 例如：固定第一个参数为10，第二个参数由调用者提供，第三个参数固定为30
    auto func = std::bind(op, 10, std::placeholders::_1, 30); //第一个参数是可调用对象！，所有是op

    // 调用时只需提供一个参数（对应 _1）
    int result = func(20);  // 等价于 op(10, 20, 30)

    std::cout << result << std::endl;

    return 0;
}
```



### 占位符

```cpp
int add(int a,int b,int c){}

auto new_add = std::bind(add, std::placeholders::_3, std::placeholders::_2, std::placeholders::_1);

new_add(1, 2, 3); //实际是调用 3, 2, 1
```

> `std::placeholders::_1`、`std::placeholders::_2` ......



### 与lambda对比

> `std::bind` 曾在C++11中广泛使用，但随着Lambda表达式的普及，很多情况下Lambda更为直观和高效。不过，在某些复杂的参数绑定场景下，`std::bind` 依然有其独特优势。

| 特性       | `std::bind`                  | `Lambda`                           |
| ---------- | ---------------------------- | ---------------------------------- |
| **语法**   | 相对复杂，需要使用占位符     | 简洁，能够直接捕获变量             |
| **性能**   | 可能有额外的开销             | 通常更高效，特别是对局部变量捕获   |
| **灵活性** | 支持部分应用、成员函数绑定等 | 更灵活，支持捕获任意变量、简洁定义 |
| **可读性** | 可能导致代码不够直观         | 更简洁易读，语法更直观             |



​	**`std::bind` 示例**

```cpp
#include <iostream>
#include <functional>

int multiply(int a, int b) {
    return a * b;
}

int main() {
    // 绑定第一个参数为2，生成新的函数对象
    auto multiplyBy2 = std::bind(multiply, 2, std::placeholders::_1);

    std::cout << "2 * 5 = " << multiplyBy2(5) << std::endl; // 输出: 2 * 5 = 10

    return 0;
}
```



​	**`lambda` 示例：**

```cpp
#include <iostream>
#include <functional>

int multiply(int a, int b) {
    return a * b;
}

int main() {
    // 使用Lambda表达式绑定第一个参数为2
    auto multiplyBy2 = [](int b) -> int {
        return multiply(2, b);
    };

    std::cout << "2 * 5 = " << multiplyBy2(5) << std::endl; // 输出: 2 * 5 = 10

    return 0;
}
```





## 绑定类的成员函数

> 在C++中，成员函数与普通函数不同，因为它们需要一个对象实例来调用。使用 `std::bind` 或 `Lambda` 表达式，可以方便地绑定类的成员函数，生成可调用对象。



### lambda绑定成员函数

​	**类外捕获示例：**

```cpp
#include <iostream>
#include <functional>
class Greeter
{
public:
  void greet(const std::string &name) const
  {
    std::cout << "Hello, " << name << "!" << std::endl;
  }
};

int main()
{
  Greeter greeter;
  // 使用Lambda表达式绑定成员函数
  // 捕获外部的实例化对象
  auto greetFunc = [&greeter](const std::string &name)
  {
    greeter.greet(name);
  };
  greetFunc("Alice"); // 输出: Hello, Alice!
  return 0;
}
```



​	**类内捕获示例:**

​	[即捕获this](#捕获this)



### std::bind绑定成员函数

​	**基本语法：**

```cpp
std::bind(&ClassName::memberFunc, object_or_pointer, args...);
```

- `&ClassName::memberFunc`：成员函数指针**（注意一定加取地址符 `&`）**

- `object_or_pointer`：调用该成员函数的对象或对象指针 **（推荐加 `&` 避免拷贝）**

- `args...`：绑定时给的参数（可以用 `_1, _2, ...` 占位符）



​	**示例：**

```cpp
#include <iostream>
#include <functional>

class Calculator
{
public:
  int multiply(int a, int b)
  {
    return a * b;
  }
};

int main()
{
  // 使用bind绑定类的成员函数，使其变成了一个新的普通函数
  Calculator calculator; // 绑定前先实例化这个对象

  /** 1. bind里面第一个参数是取类成员函数的地址，普通函数名即函数地址，而类成员函数需要手动取地址
   *  2.第二个参数是该成员函数的实例化对象的地址，因为要将成员函数绑定到实例化对象上才能调用。
   *  3. 第三第四就是成员函数的参数了，第一个默认，第二个占位
   * **/
  auto new_multiply = std::bind(&Calculator::multiply, &calculator, 5, std::placeholders::_1);
  std::cout << "5 * 3 = " << new_multiply(3) << std::endl;
}
```

| 写法          | 类型          | 是否复制对象 | 调用哪一个对象 |
| ------------- | ------------- | ------------ | -------------- |
| `&calculator` | `Calculator*` | ❌ 不复制     | 原对象         |
| `calculator`  | `Calculator`  | ✅ 会复制     | 副本           |





### 绑定静态成员函数

> 静态成员函数不依赖于类的实例，就不用绑定实例化对象了。可以像普通函数一样使用 `std::bind` 和 `std::function`。

​	**示例：**

```cpp
#include <iostream>
#include <functional>

class Logger 
{
public:
    static void log(const std::string& message)
    {
        std::cout << "Log: " << message << std::endl;
    }
};

int main()
{
    // 使用std::bind绑定静态成员函数
    auto logFunc = std::bind(&Logger::log, std::placeholders::_1); //不用绑定对象

    logFunc("This is a static log message."); // 输出: Log: This is a static log message.

    return 0;
}
```



## 综合案例

```cpp
#include <iostream>
#include <functional>
#include <vector>
#include <algorithm>

// 1. 普通函数
int add(int a, int b) {
    return a + b;
}

// 2. 仿函数（Functors）
struct Multiply {
    int operator()(int a, int b) const {
        return a * b;
    }
};

// 3. Lambda表达式
auto subtract = [](int a, int b) -> int {
    return a - b;
};

// 4. 类定义
class Calculator {
public:
    int subtract(int a, int b) const {
        return a - b;
    }

    void displayOperation(const std::string& op, int result) const {
        std::cout << op << "结果: " << result << std::endl;
    }
};

// 5. 静态成员函数
class Logger {
public:
    static void log(const std::string& message) {
        std::cout << "Log: " << message << std::endl;
    }
};

int main() {
    // 1. 函数指针
    int (*funcPtr)(int, int) = &add;
    std::cout << "Add (Function Pointer): " << funcPtr(10, 5) << std::endl; // 输出: 15

    // 2. 仿函数（Functors）
    Multiply multiply;
    std::cout << "Multiply (Functors): " << multiply(10, 5) << std::endl; // 输出: 50

    // 3. Lambda表达式
    std::cout << "Subtract (Lambda): " << subtract(10, 5) << std::endl; // 输出: 5

    // 4. std::function 封装不同可调用对象
    std::function<int(int, int)> funcAdd = add;
    std::function<int(int, int)> funcSubtract = subtract;
    std::function<int(int, int)> funcMultiply = multiply;

    std::cout << "Add (std::function): " << funcAdd(20, 10) << std::endl; // 输出: 30
    std::cout << "Subtract (std::function): " << funcSubtract(20, 4) << std::endl; // 输出: 16
    std::cout << "Multiply (std::function): " << funcMultiply(4, 5) << std::endl; // 输出: 20

    // 5. std::bind 绑定部分参数
    auto add5 = std::bind(add, 5, std::placeholders::_1);
    std::cout << "5 + 10 = " << add5(10) << std::endl; // 输出: 15

    auto multiplyBy2 = std::bind(multiply, 2, std::placeholders::_1);
    std::cout << "2 * 10 = " << multiplyBy2(10) << std::endl; // 输出: 20

    // 6. 绑定类成员函数
    Calculator calc;

    // 使用 std::bind 绑定成员函数 subtract
    auto boundSubtract = std::bind(&Calculator::subtract, &calc, 15, 5);
    std::cout << "15 - 5 = " << boundSubtract() << std::endl; // 输出: 10

    // 使用 std::bind 绑定成员函数 displayOperation
    auto displayAdd = std::bind(&Calculator::displayOperation, &calc, "Add", std::placeholders::_1);
    auto displayResult = funcAdd;
    int addResult = displayResult(7, 8); // 15
    displayAdd(addResult); // 输出: Add结果: 15

    // 7. 绑定静态成员函数
    auto logFunc = std::bind(&Logger::log, std::placeholders::_1);
    logFunc("This is a static log message."); // 输出: Log: This is a static log message.

    // 8. 使用 std::function 存储混合可调用对象
    std::vector<std::function<void()>> operations;

    // 添加不同的操作到容器
    operations.emplace_back([&]() { std::cout << "Lambda Operation" << std::endl; });
    operations.emplace_back(std::bind(&Calculator::displayOperation, &calc, "Multiply", 30));
    operations.emplace_back([&]() { std::cout << "Add5(10): " << add5(10) << std::endl; });
    operations.emplace_back([&]() { Logger::log("Lambda-based log message."); });

    // 执行所有操作
    for(auto& op : operations) {
        op();
    }
    /*
    输出:
    Lambda Operation
    Multiply结果: 30
    Add5(10): 15
    Log: Lambda-based log message.
    */

    return 0;
}
```



1. **函数指针:** 定义并使用了指向 `add` 函数的函数指针 `funcPtr`。

2. **仿函数（Functors）:** 定义了 `Multiply` 结构体，并使用其实例 `multiply` 进行乘法运算。

3. **Lambda表达式:** 定义了一个用于减法的Lambda `subtract`。

5. `std::function`**:** 封装了不同类型的可调用对象，包括普通函数、Lambda和仿函数。

6. `std::bind`**:** 绑定 `add` 和 `multiply` 函数的部分参数，生成新的可调用对象 `add5` 和 `multiplyBy2`。

7. **绑定类成员函数:** 使用 `std::bind` 绑定 `Calculator` 类的成员函数 `subtract` 和 `displayOperation`。

8. **绑定静态成员函数:** 使用 `std::bind` 绑定 `Logger` 类的静态成员函数 `log`。

9. **混合可调用对象容器:** 使用 `std::function` 和 `std::vector` 存储并执行不同类型的可调用对象，包括Lambda、绑定成员函数和静态成员函数。
